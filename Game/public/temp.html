Index.html
<!DOCTYPE html>
<html>
<head>
<title>99 Idea (Styled)</title>
<style>
body {
    font-family: Arial;
    display:flex;
    flex-direction:column;
    align-items:center;
    background:#0a0a0a;
    color:#fff;
}
h2 {
    margin-top:20px;
    font-size:30px;
    color:#00ffe7;
    text-shadow:0 0 18px #00ffee;
}
#board{
    display:grid;
    gap:4px;
    margin-top:25px;
}
.cell{
    width:55px; height:55px;
    border-radius:10px;
    background:#1c1c1c;
    box-shadow:0 0 10px #000 inset;
    display:flex;
    justify-content:center;
    align-items:center;
}
.dot{
    width:30px; height:30px;
    border-radius:50%;
    transition:0.25s;
    box-shadow:0 0 12px currentColor;
}
.king{
    width:34px; height:34px;
    border-radius:50%;
    border:3px solid gold;
    box-shadow:0 0 15px gold;
    transition:0.25s;
}
button{
    padding:10px 15px;
    margin:5px;
    font-size:18px;
    border-radius:8px;
    background:#111;
    color:#00fff6;
    border:2px solid #00fff6;
    cursor:pointer;
    transition:0.2s;
}
button:hover{
    background:#00fff6;
    color:#000;
}
.levelButtons button{font-size:16px;}
#hintArrow{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    font-size:130px;
    color:#00ffe1;
    opacity:0;
    transition:opacity .4s;
    pointer-events:none;
    text-shadow:0 0 30px #00fff2;
}
#successBox{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    background:#111;
    padding:25px 40px;
    border:3px solid #00fff2;
    border-radius:12px;
    color:#00fff6;
    font-size:26px;
    display:none;
    box-shadow:0 0 25px #00fff6;
}
</style>
</head>
<body>

<h2>99 Idea</h2>

<div class="levelButtons">
    <button onclick="setLevel('Easy')">Easy</button>
    <button onclick="setLevel('Medium')">Medium</button>
    <button onclick="setLevel('Hard')">Hard</button>
</div>

<div id="board"></div>

<div id="controls">
    <button onclick="moveAll(-1,0)">↑</button>
    <button onclick="moveAll(1,0)">↓</button>
    <button onclick="moveAll(0,-1)">←</button>
    <button onclick="moveAll(0,1)">→</button>
    <button onclick="createPuzzle()">New Puzzle</button>
    <button onclick="setEntry()">SET</button>
    <button onclick="giveUpAndHint()">Give Up & Hint</button>
</div>

<div id="hintArrow">↑</div>
<div id="successBox">SUCCESS!</div>

<script>
// ========== GLOBALS ==========
let SIZE=7, NUM_BALLS=3;
const COLORS=["red","yellow","cyan","lime","orange","violet","deeppink"];
let board=document.getElementById("board");
let cells=[];
let blobs=[];
let currentLevel="Easy";

// ========== LEVEL SETUP ==========
function setLevel(level){
    currentLevel=level;
    if(level==="Easy"){SIZE=7; NUM_BALLS=3;}
    else if(level==="Medium"){SIZE=9; NUM_BALLS=5;}
    else if(level==="Hard"){SIZE=12; NUM_BALLS=7;}
    createPuzzle();
}

// ========== GRID ==========
function initGrid(){
    board.innerHTML="";
    board.style.gridTemplateColumns=`repeat(${SIZE},55px)`;
    board.style.gridTemplateRows=`repeat(${SIZE},55px)`;
    cells=[];
    for(let r=0;r<SIZE;r++){
        cells[r]=[];
        for(let c=0;c<SIZE;c++){
            let d=document.createElement("div");
            d.className="cell";
            board.appendChild(d);
            cells[r][c]=d;
        }
    }
}

// ========== RANDOM CELL ==========
function randomCell(used){
    while(true){
        let r=Math.floor(Math.random()*SIZE);
        let c=Math.floor(Math.random()*SIZE);
        let k=r+"-"+c;
        if(!used.has(k)){
            used.add(k);
            return [r,c];
        }
    }
}

// ========== CREATE PUZZLE ==========
function createPuzzle(){
    initGrid();
    blobs=[];
    let used=new Set();
    for(let i=0;i<NUM_BALLS;i++){
        let s=randomCell(used);
        let t=randomCell(used);
        let color=COLORS[i%COLORS.length];
        blobs.push({color,pos:[s[0],s[1]],target:[t[0],t[1]]});
        cells[s[0]][s[1]].innerHTML=`<div class='dot' style='background:${color};color:${color}'></div>`;
        cells[t[0]][t[1]].innerHTML=`<div class='dot' style='background:#000;border:3px solid ${color};color:${color}'></div>`;
    }
}

// ========== MOVE ALL ==========
function moveAll(dr,dc){
    let newPos = blobs.map(b=>{
        let [r,c]=b.pos;
        let nr=r+dr, nc=c+dc;
        if(nr<0||nr>=SIZE||nc<0||nc>=SIZE) return [r,c];
        let isTarget = blobs.some(bb=>bb.target[0]==nr && bb.target[1]==nc);
        if(isTarget){
            let ok = blobs.every(bb=>{let br=bb.pos[0]+dr, bc=bb.pos[1]+dc; return (br==bb.target[0] && bc==bb.target[1]);});
            if(!ok) return [r,c];
        }
        let blocked = blobs.some(bb=>bb.pos[0]==nr && bb.pos[1]==nc);
        if(blocked) return [r,c];
        return [nr,nc];
    });
    blobs.forEach(b=>cells[b.pos[0]][b.pos[1]].innerHTML="");
    blobs.forEach((b,i)=>{
        b.pos=newPos[i];
        let [r,c]=b.pos;
        cells[r][c].innerHTML=`<div class='dot' style='background:${b.color};color:${b.color}'></div>`;
    });
}

// ========== SET ENTRY ==========
function setEntry(){
    let ok = blobs.every(b=>{
        let [r,c]=b.pos;
        let [tr,tc]=b.target;
        return Math.abs(r-tr)+Math.abs(c-tc)===1;
    });
    if(!ok){
        alert("⚠ Pehle sabhi balls ko apne target ke paas (side me) lao!");
        return;
    }
    blobs.forEach(b=>cells[b.pos[0]][b.pos[1]].innerHTML="");
    blobs.forEach(b=>{
        let [tr,tc]=b.target;
        b.pos=[tr,tc];
        cells[tr][tc].innerHTML=`<div class='king' style='background:${b.color}'></div>`;
    });
    document.getElementById("successBox").style.display="block";
    setTimeout(()=>document.getElementById("successBox").style.display="none",2000);
}

// ========== HINT ARROW ==========
function showHintArrow(dir){
    let arrow=document.getElementById("hintArrow");
    arrow.innerHTML = dir==="UP"?"↑":dir==="DOWN"?"↓":dir==="LEFT"?"←":"→";
    arrow.style.opacity=1;
    setTimeout(()=>arrow.style.opacity=0,1200);
}

// ========== LOCAL BFS FOR EASY ==========
function cloneBlobs(bl){return bl.map(b=>({color:b.color,pos:[b.pos[0],b.pos[1]],target:[b.target[0],b.target[1]]}));}
function encodeState(bl){return bl.map(b=>b.pos[0]+","+b.pos[1]).join("|");}
function isSolved(bl){return bl.every(b=>Math.abs(b.pos[0]-b.target[0])+Math.abs(b.pos[1]-b.target[1])==1);}
function applyMove(bl,dr,dc){
    let sim=cloneBlobs(bl);
    for(let i=0;i<sim.length;i++){
        let [r,c]=sim[i].pos;
        let nr=r+dr,nc=c+dc;
        if(nr<0||nr>=SIZE||nc<0||nc>=SIZE) continue;
        let blocked=sim.some((bb,j)=>j!=i && bb.pos[0]==nr && bb.pos[1]==nc);
        if(blocked) continue;
        let isTarget = sim.some(bb=>bb.target[0]==nr && bb.target[1]==nc);
        if(isTarget){
            let canEnter = sim.every(bb=>{let br=bb.pos[0]+dr; let bc=bb.pos[1]+dc; return (br==bb.target[0] && bc==bb.target[1]);});
            if(!canEnter) continue;
        }
        sim[i].pos=[nr,nc];
    }
    return sim;
}
function computeBFSHint(){
    let q=[],visited=new Set();
    q.push({bl:cloneBlobs(blobs),path:[]});
    visited.add(encodeState(blobs));
    const moves=[{n:"UP",dr:-1,dc:0},{n:"DOWN",dr:1,dc:0},{n:"LEFT",dr:0,dc:-1},{n:"RIGHT",dr:0,dc:1}];
    while(q.length){
        let node=q.shift();
        if(isSolved(node.bl)) return node.path[0]||null;
        for(let mv of moves){
            let nxt=applyMove(node.bl,mv.dr,mv.dc);
            let code=encodeState(nxt);
            if(!visited.has(code)){
                visited.add(code);
                q.push({bl:nxt,path:[...node.path,mv.n]});
            }
        }
    }
    return null;
}

// ========== GIVE HINT ==========
// ========== GIVE HINT ==========
function giveUpAndHint() {
    let bestMove = null;
    let maxDistReduction = -1;

    const moves = [
        {name:"UP", dr:-1, dc:0},
        {name:"DOWN", dr:1, dc:0},
        {name:"LEFT", dr:0, dc:-1},
        {name:"RIGHT", dr:0, dc:1}
    ];

    blobs.forEach(b => {
        moves.forEach(mv => {
            let nr = b.pos[0] + mv.dr;
            let nc = b.pos[1] + mv.dc;

            // Grid check
            if(nr<0 || nr>=SIZE || nc<0 || nc>=SIZE) return;

            // Block check
            if(blobs.some(bb => bb.pos[0]==nr && bb.pos[1]==nc)) return;

            // Distance reduction
            let oldDist = Math.abs(b.pos[0]-b.target[0]) + Math.abs(b.pos[1]-b.target[1]);
            let newDist = Math.abs(nr-b.target[0]) + Math.abs(nc-b.target[1]);
            let reduction = oldDist - newDist;

            // Choose move with maximum reduction
            if(reduction > maxDistReduction) {
                maxDistReduction = reduction;
                bestMove = mv.name;
            }
        });
    });

    if(bestMove) showHintArrow(bestMove);
    else alert("No hint available!");
}

// ========== INIT GAME ==========
setLevel("Easy");

</script>
</body>
</html>


